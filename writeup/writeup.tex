\documentclass{article}

\usepackage{url,listings}
\lstset{
  language=Lisp,
  basicstyle=\ttfamily,
  showstringspaces=false}

\title{\texttt{ambc}: the most general \texttt{amb}}
\author{Jacob Hurwitz \and David Lawrence \and Steven Valdez}

\begin{document}

\maketitle

\begin{center}
  Source code is available at \url{http://github.com/dvorak42/pramb}.
\end{center}

\section{Introduction and motivation}

The \texttt{amb} function provides a clean mechanism for programs to
make discrete choices by implicit backtracking.  We aimed to extend
\texttt{amb} so that it might also represent decisions over an
undetermined or possibly infinite space of alternatives.  We were
motivated by a desire to use \texttt{amb} to manipulate random
variables that might have particular probability distributions.

We elected to implement a new interface called
``\texttt{amb}-continuation'', or \texttt{ambc}.  Rather then being
called with a list of alternatives, \texttt{ambc} would be called with
a function that produced new alternatives on-demand.  That function
would itself be passed success and failure continuations, which it
could then call to indicate succees (with a particular value) or
failure as appropriate.

\begin{lstlisting}
;;; Evaluates to 22 forever
(ambc
  (lambda (succeed fail)
    (succeed 22)))

;;; Fails immediately
(ambc
  (lambda (succeed fail)
    (fail)))
\end{lstlisting}

For \texttt{ambc} to do anything useful, it needed some way to
maintain state between invocations.  Accordingly, we arranged that the
parent environment of \texttt{ambc}'s argument would not be reset
between alternatives.  With that done, we could easily define
traditional \texttt{amb} in terms of \texttt{ambc}:
\begin{lstlisting}
(define (amb . alts)
  (ambc
   (lambda (succeed fail)
     (if (null? alts)
         (fail)
         (let ((result (car alts)))
           (set! alts (cdr alts))
           (succeed result))))))
\end{lstlisting}
We could also do new things, like selecting from a range of
floating-point numbers:
\begin{lstlisting}
(define (amb-range low high)
  (ambc
   (lambda (succeed fail)
     (succeed (random-float low high))))
\end{lstlisting}

In the remaining sections, we will discuss the implementation of
\texttt{ambc} and our efforts to use it as a mechanism for
representing random variables in Scheme.

\section{Implementation of \texttt{ambc}}

We started with the analyzing Scheme interpreter from problem set 4.
The failure continuations in this interpreter implicitly define a
stack, resulting in the backtracking procedure executing via
depth-first search.  However, depth-first search is not suitable when
there are choices from infinite sets of alternatives: the search would
spend forever on the first infinite option and never try a new
alternative for any other ambiguous values.

In order to implement breadth-first search instead, we'll have to
develop a solution that more explicitly allows storing and restoration
of environment state.

\section{\texttt{ambc} test cases}

\section{Applications to probability}
Once we implemented \texttt{ambc}, we were then able to apply it to probability
distributions in order to begin selecting over the values of the probability
distribution. In order to manipulate and deal with probability objects,
\textit{probobjs}, we constructed methods to transform these objects and combine
them together:

\begin{itemize}
  \item \textbf{p:sum}: Returns a probobj that is the sum of the input probobjs.
  \item \textbf{p:mult}: Returns a probobj that is the product of the input probobjs.
  \item \textbf{p:scale}: Returns a probobj that is the scaled form of the input.
  \item \textbf{p:shift}: Returns a probobj that is a shifted version of the
    input.
\end{itemize}

Once we had established a set of operations to perform on the probobjs, we are
then able to generate more complex probability distributions from the initial
uniform probability distribution. In order to help ensure the probability
distributions are correct, and to visualize the output of the probobjs, we also
implemented a ``p:display'' function that would generate a visual representation
of the probobj by taking many samples which are then placed into bins across the
distribution.

In addition to the methods that we created to manipulate probobjs, we are also
able to use our \texttt{ambc} construction to generate probobjs deriving from
the input one. For example, we can generate the part of the normal distribution
above $0.25$ by using:

\begin{lstlisting}
(define (px s f) 
  (let ((p (ambc p:normal))) 
    (require (> p 0.25))
    (s p)))
\end{lstlisting}

TODO ABOUT MONTE-CARLO STUFF.
\section{Directions for future work}

\end{document}
